// SPDX-License-Identifier: MIT
/// @title Implementation of view functions for joint accounts for GR14 Hackathon. Modified from version created by Samuele Marro: https://github.com/samuelemarro/gr13-vite-joint-account
/// @author Jethro Fredericks

pragma soliditypp ^0.8.0;

interface IJointAccountsViews {
    function motionExists(uint256 _accountId, uint256 _motionId) external view returns (bool);
    function accountExists(uint256 _accountId) external view returns(bool);
}

enum MotionType { TRANSFER, ADD_MEMBER, REMOVE_MEMBER, CHANGE_THRESHOLD }

struct Motion {
    MotionType motionType;
    vitetoken tokenId;
    uint256 transferAmount;
    address to;
    uint256 destinationAccount;
    uint256 threshold;

    address proposer;
    uint256 voteCount;
    bool active;
}

struct JointAccount {
    address[] members;
    uint256 approvalThreshold;
    bool isStatic;
    bool isMemberOnlyDeposit;
}


// interface Listener {
//     function accountsCallback(JointAccount memory accounts) external;
//     function userAccountsCallback(uint256 _accountId, address _userAddress) external;
// }

// contract JointAccountsViews is Listener {
contract JointAccountsViews {
    address public accountsContractAddress;
    JointAccount[] accounts;
    mapping(address => uint256[]) userAccounts;
    mapping(uint256 => mapping(vitetoken => uint256)) public balances;

    // function setJointAccountContractAddress(address _contractAddress) external {
    //     accountsContractAddress = _contractAddress;
    //     jointsAccountsContract = IJointAccounts(accountsContractAddress);
    // }

    function accountsCallback(JointAccount memory _account) external {
        JointAccount storage newAccount = accounts.push();
        newAccount.approvalThreshold = _account.approvalThreshold;
        newAccount.isStatic = _account.isStatic;
        newAccount.isMemberOnlyDeposit = _account.isMemberOnlyDeposit;
    }

    function userAccountsCallback(uint256 _accountId, address _userAddress) external {
        accounts[_accountId].members.push(_userAddress);
        userAccounts[_userAddress].push(_accountId);
    }

    function depositCallback(uint256 _accountId, vitetoken _tokenId, uint256 _amount) external {
        balances[_accountId][_tokenId] = _amount;
    }

    function getAccount(uint256 _accountId) external view returns(JointAccount memory) {
        return accounts[_accountId];
    }

    function getUserAccounts(address _userAddress) external view returns (uint256[] memory){
        return userAccounts[_userAddress];
    }

    function getNumUserAccounts(address _userAddress) external view returns (uint256){
        return userAccounts[_userAddress].length;
    }

    function getNumAccounts() external view returns(uint256) {
        return accounts.length;
    }

    function _accountCheck(uint256 _accountId) private view {
        require(_accountId < accounts.length, "E5" ); // "E5" -> "Account does not exist"
    }

    // ===Getters===

    /// @notice Returns true if an account exists
    ///
    /// @param _accountId Account Id
    function accountExists(uint256 _accountId) external view returns(bool) {
        return _accountId < accounts.length;
    }

    /// @notice Returns the approval threshold of an account
    ///
    /// @param _accountId Account Id
    function approvalThreshold(uint256 _accountId) public view returns(uint256) {
        _accountCheck(_accountId);
        return accounts[_accountId].approvalThreshold;
    }

    /// @notice Returns true if an account is static
    ///
    /// @param _accountId Account Id
    function isStatic(uint256 _accountId) external view returns(bool) {
        _accountCheck(_accountId);
        return accounts[_accountId].isStatic;
    }

    /// @notice Returns true if an account has a member-only deposit policy
    ///
    /// @param _accountId Account Id
    function isMemberOnlyDeposit(uint256 _accountId) external view returns(bool) {
        _accountCheck(_accountId);
        return accounts[_accountId].isMemberOnlyDeposit;
    }

    /// @notice Returns the balance of an account
    ///
    /// @param _accountId Account Id
    /// @param _tokenId Token Id
    function balanceOf(uint256 _accountId, vitetoken _tokenId) external view returns(uint256) {
        _accountCheck(_accountId);
        return balances[_accountId][_tokenId];
    }

    /// @notice Returns the current members
    ///
    /// @param _accountId Account id
    function getMembers(uint256 _accountId) external view returns (address[] memory) {
        _accountCheck(_accountId);
        return accounts[_accountId].members;
    }


    // Removed to reduce contract size
    /// @notice Returns the number of members
    function memberCount(uint256 _accountId) external view returns (uint256) {
        require(_accountId < accounts.length, "Account does not exist");
        return accounts[_accountId].members.length;
    }

    /// @notice Returns true if a motion exists
    ///
    /// @param _motionId The queried motion id
    // function motionExists(uint256 _accountId, uint256 _motionId) internal view returns (bool) {
    //     require(_accountId < IJointAccounts(accountsContractAddress).accounts().length, "E5");  // "E5" -> "Account does not exist"
    //     // return _motionId < IJointAccounts(accountsContractAddress).accounts()[_accountId].motions.length;
    // }
    
    // function _basicChecks(uint256 _accountId, uint256 _motionId) private view {
    //     // Already handled by motionExists
    //     // require(accountExists(_accountId), "Account does not exist");
    //     require(motionExists(_accountId, _motionId), "E6"); // "E6" -> "Motion does not exist" 
    // }

    /// @notice Returns the type of a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    ///
    /// @return 0 = Transfer, 1 = Add Member, 2 = Remove Member, 3 = Change Threshold
    // function motionType(uint256 _accountId, uint256 _motionId) external view returns (uint256) {
    //     _basicChecks(_accountId, _motionId);
    //     // return uint256(IJointAccounts(accountsContractAddress).accounts()[_accountId].motions[_motionId].motionType);
    // }

    /// @notice Returns the token id of a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    // function tokenId(uint256 _accountId, uint256 _motionId) external view returns (vitetoken) {
    //     _basicChecks(_accountId, _motionId);
    //     return IJointAccounts(accountsContractAddress).accounts()[_accountId].motions[_motionId].tokenId;
    // }

    /// @notice Returns the transfer amount of a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    // function transferAmount(uint256 _accountId, uint256 _motionId) external view returns (uint256) {
    //     _basicChecks(_accountId, _motionId);
    //     return IJointAccounts(accountsContractAddress).accounts()[_accountId].motions[_motionId].transferAmount;
    // }

    /// @notice Returns the relevant address of a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    // function to(uint256 _accountId, uint256 _motionId) external view returns (address) {
    //     _basicChecks(_accountId, _motionId);
    //     return IJointAccounts(accountsContractAddress).accounts()[_accountId].motions[_motionId].to;
    // }

    /// @notice Returns the destination account of a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    // function destinationAccount(uint256 _accountId, uint256 _motionId) external view returns (uint256) {
    //     _basicChecks(_accountId, _motionId);
    //     return IJointAccounts(accountsContractAddress).accounts()[_accountId].motions[_motionId].destinationAccount;
    // }

    /// @notice Returns the proposed threshold of a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    // function threshold(uint256 _accountId, uint256 _motionId) external view returns (uint256) {
    //     _basicChecks(_accountId, _motionId);
    //     // return IJointAccounts(accountsContractAddress).accounts()[_accountId].motions[_motionId].threshold;
    // }

    /// @notice Returns the proposer of a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    // function proposer(uint256 _accountId, uint256 _motionId) external view returns (address) {
    //     _basicChecks(_accountId, _motionId);
    //     // return IJointAccounts(accountsContractAddress).accounts()[_accountId].motions[_motionId].proposer;
    // }

    /// @notice Returns the number of votes for a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    // function voteCount(uint256 _accountId, uint256 _motionId) external view returns (uint256) {
    //     _basicChecks(_accountId, _motionId);
    //     // return IJointAccounts(accountsContractAddress).accounts()[_accountId].motions[_motionId].voteCount;
    // }

    /// @notice Returns the number of votes for a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    // function active(uint256 _accountId, uint256 _motionId) external view returns (bool) {
    //     _basicChecks(_accountId, _motionId);
    //     // return IJointAccounts(accountsContractAddress).accounts()[_accountId].motions[_motionId].active;
    // }

    /// @notice Returns true if a member voted for a motion
    ///
    /// @param _accountId Account id
    /// @param _motionId The queried motion id
    /// @param _voter The queried member
    // function voted(uint256 _accountId, uint256 _motionId, address _voter) external view returns (bool) {
    //     _basicChecks(_accountId, _motionId);
    //     return IJointAccounts(accountsContractAddress).votes(_accountId, _motionId, _voter);
    // }
}